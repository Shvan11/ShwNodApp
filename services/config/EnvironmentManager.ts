// services/config/EnvironmentManager.ts
/**
 * Environment Manager Service
 * Handles reading, writing, and managing .env configuration files
 */

import fs from 'fs/promises';
import fs_sync from 'fs';
import path from 'path';
import { log } from '../../utils/logger.js';

/**
 * Database configuration interface
 */
export interface DatabaseConfig {
  DB_SERVER: string;
  DB_INSTANCE: string;
  DB_DATABASE: string;
  DB_USER: string;
  DB_PASSWORD: string;
  DB_ENCRYPT: string;
  DB_TRUST_CERTIFICATE: string;
  DB_CONNECTION_TIMEOUT: string;
  DB_REQUEST_TIMEOUT: string;
}

/**
 * Environment validation result interface
 */
export interface EnvironmentValidation {
  valid: boolean;
  message: string;
  missing?: string[];
  suggestions?: string[];
  config?: DatabaseConfig;
  error?: string;
}

/**
 * File status interface
 */
export interface FileStatus {
  envExists: boolean;
  backupExists: boolean;
  templateExists: boolean;
  envModified?: Date;
  envSize?: number;
  envError?: string;
  backupModified?: Date;
  backupSize?: number;
  backupError?: string;
}

class EnvironmentManager {
  private envPath: string;
  private backupPath: string;
  private templatePath: string;

  constructor() {
    this.envPath = path.join(process.cwd(), '.env');
    this.backupPath = path.join(process.cwd(), '.env.backup');
    this.templatePath = path.join(process.cwd(), '.env.template');
  }

  /**
   * Read and parse the current .env file
   */
  async readEnvFile(): Promise<Record<string, string>> {
    try {
      const envContent = await fs.readFile(this.envPath, 'utf8');
      return this.parseEnvContent(envContent);
    } catch (error) {
      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
        log.warn('No .env file found, returning empty configuration');
        return {};
      }
      throw new Error(`Failed to read .env file: ${(error as Error).message}`);
    }
  }

  /**
   * Parse environment file content into key-value pairs
   */
  parseEnvContent(content: string): Record<string, string> {
    const env: Record<string, string> = {};
    const lines = content.split('\n');

    for (const line of lines) {
      const trimmed = line.trim();

      // Skip empty lines and comments
      if (!trimmed || trimmed.startsWith('#')) {
        continue;
      }

      // Parse key=value pairs
      const equalIndex = trimmed.indexOf('=');
      if (equalIndex > 0) {
        const key = trimmed.substring(0, equalIndex).trim();
        let value = trimmed.substring(equalIndex + 1).trim();

        // Remove quotes if present
        if (
          (value.startsWith('"') && value.endsWith('"')) ||
          (value.startsWith("'") && value.endsWith("'"))
        ) {
          value = value.slice(1, -1);
        }

        env[key] = value;
      }
    }

    return env;
  }

  /**
   * Convert environment object back to .env file format
   */
  formatEnvContent(envVars: Record<string, string>): string {
    const lines: string[] = [
      '# Database Configuration',
      '# Generated by Shwan Orthodontics Settings',
      `# Updated: ${new Date().toISOString()}`,
      '',
    ];

    // Database configuration section
    const dbVars = Object.keys(envVars)
      .filter((key) => key.startsWith('DB_'))
      .sort();

    if (dbVars.length > 0) {
      lines.push('# Database Connection Settings');
      for (const key of dbVars) {
        const value = envVars[key];
        // Quote values that contain spaces or special characters
        const quotedValue = this.shouldQuoteValue(value) ? `"${value}"` : value;
        lines.push(`${key}=${quotedValue}`);
      }
      lines.push('');
    }

    // Other configuration sections
    const otherVars = Object.keys(envVars)
      .filter((key) => !key.startsWith('DB_'))
      .sort();

    if (otherVars.length > 0) {
      lines.push('# Other Configuration');
      for (const key of otherVars) {
        const value = envVars[key];
        const quotedValue = this.shouldQuoteValue(value) ? `"${value}"` : value;
        lines.push(`${key}=${quotedValue}`);
      }
    }

    return lines.join('\n') + '\n';
  }

  /**
   * Determine if a value should be quoted in .env file
   */
  shouldQuoteValue(value: string): boolean {
    if (typeof value !== 'string') return false;

    // Quote if contains spaces, special characters, or is empty
    return (
      value.includes(' ') ||
      value.includes('\t') ||
      value.includes('\n') ||
      value.includes('#') ||
      value.includes('=') ||
      value === ''
    );
  }

  /**
   * Create a backup of the current .env file
   */
  async createBackup(): Promise<boolean> {
    try {
      if (fs_sync.existsSync(this.envPath)) {
        await fs.copyFile(this.envPath, this.backupPath);
        log.info('Environment backup created successfully');
        return true;
      }
      return false;
    } catch (error) {
      log.error('Failed to create environment backup', { error: (error as Error).message });
      throw new Error(`Backup creation failed: ${(error as Error).message}`);
    }
  }

  /**
   * Restore .env file from backup
   */
  async restoreFromBackup(): Promise<boolean> {
    try {
      if (fs_sync.existsSync(this.backupPath)) {
        await fs.copyFile(this.backupPath, this.envPath);
        log.info('Environment restored from backup successfully');
        return true;
      }
      throw new Error('No backup file found');
    } catch (error) {
      log.error('Failed to restore from backup', { error: (error as Error).message });
      throw new Error(`Restore failed: ${(error as Error).message}`);
    }
  }

  /**
   * Write new environment configuration to .env file
   */
  async writeEnvFile(envVars: Record<string, string>, createBackup = true): Promise<boolean> {
    try {
      // Create backup if requested and file exists
      if (createBackup) {
        await this.createBackup();
      }

      // Format and write new content
      const content = this.formatEnvContent(envVars);
      await fs.writeFile(this.envPath, content, 'utf8');

      log.info('Environment file updated successfully');
      return true;
    } catch (error) {
      log.error('Failed to write environment file', { error: (error as Error).message });
      throw new Error(`Write failed: ${(error as Error).message}`);
    }
  }

  /**
   * Update specific environment variables
   */
  async updateEnvVars(
    updates: Record<string, string>,
    createBackup = true
  ): Promise<Record<string, string>> {
    try {
      // Read current environment
      const currentEnv = await this.readEnvFile();

      // Merge with updates
      const updatedEnv = { ...currentEnv, ...updates };

      // Write back to file
      await this.writeEnvFile(updatedEnv, createBackup);

      return updatedEnv;
    } catch (error) {
      log.error('Failed to update environment variables', { error: (error as Error).message });
      throw new Error(`Update failed: ${(error as Error).message}`);
    }
  }

  /**
   * Get database configuration from environment
   */
  async getDatabaseConfig(): Promise<DatabaseConfig> {
    try {
      const env = await this.readEnvFile();

      return {
        DB_SERVER: env.DB_SERVER || '',
        DB_INSTANCE: env.DB_INSTANCE || '',
        DB_DATABASE: env.DB_DATABASE || 'ShwanNew',
        DB_USER: env.DB_USER || '',
        DB_PASSWORD: env.DB_PASSWORD || '',
        DB_ENCRYPT: env.DB_ENCRYPT || 'false',
        DB_TRUST_CERTIFICATE: env.DB_TRUST_CERTIFICATE || 'true',
        DB_CONNECTION_TIMEOUT: env.DB_CONNECTION_TIMEOUT || '30000',
        DB_REQUEST_TIMEOUT: env.DB_REQUEST_TIMEOUT || '15000',
      };
    } catch (error) {
      log.error('Failed to get database configuration', { error: (error as Error).message });
      throw new Error(`Database config read failed: ${(error as Error).message}`);
    }
  }

  /**
   * Update database configuration
   */
  async updateDatabaseConfig(dbConfig: Partial<DatabaseConfig>): Promise<DatabaseConfig> {
    try {
      // Validate required fields
      const required: Array<keyof DatabaseConfig> = [
        'DB_SERVER',
        'DB_INSTANCE',
        'DB_DATABASE',
        'DB_USER',
        'DB_PASSWORD',
      ];
      for (const field of required) {
        if (!dbConfig[field] || dbConfig[field]!.trim() === '') {
          throw new Error(`Required field ${field} is missing or empty`);
        }
      }

      // Prepare database-specific updates
      const dbUpdates: Record<string, string> = {};
      const validFields: Array<keyof DatabaseConfig> = [
        'DB_SERVER',
        'DB_INSTANCE',
        'DB_DATABASE',
        'DB_USER',
        'DB_PASSWORD',
        'DB_ENCRYPT',
        'DB_TRUST_CERTIFICATE',
        'DB_CONNECTION_TIMEOUT',
        'DB_REQUEST_TIMEOUT',
      ];

      for (const field of validFields) {
        if (dbConfig[field] !== undefined) {
          dbUpdates[field] = dbConfig[field]!.toString().trim();
        }
      }

      // Update environment
      await this.updateEnvVars(dbUpdates, true);

      // Return only database configuration
      return this.getDatabaseConfig();
    } catch (error) {
      log.error('Failed to update database configuration', { error: (error as Error).message });
      throw new Error(`Database config update failed: ${(error as Error).message}`);
    }
  }

  /**
   * Validate environment file exists and is readable
   */
  async validateEnvironment(): Promise<EnvironmentValidation> {
    try {
      const exists = fs_sync.existsSync(this.envPath);
      if (!exists) {
        return {
          valid: false,
          message: '.env file does not exist',
          suggestions: ['Create .env file from template', 'Initialize with default values'],
        };
      }

      const dbConfig = await this.getDatabaseConfig();

      // Check for required database fields
      const required: Array<keyof DatabaseConfig> = [
        'DB_SERVER',
        'DB_INSTANCE',
        'DB_USER',
        'DB_PASSWORD',
      ];
      const missing = required.filter((field) => !dbConfig[field]);

      if (missing.length > 0) {
        return {
          valid: false,
          message: `Missing required database configuration: ${missing.join(', ')}`,
          missing,
          suggestions: ['Add missing database configuration fields'],
        };
      }

      return {
        valid: true,
        message: 'Environment configuration is valid',
        config: dbConfig,
      };
    } catch (error) {
      return {
        valid: false,
        message: `Environment validation failed: ${(error as Error).message}`,
        error: (error as Error).message,
      };
    }
  }

  /**
   * Get configuration file status
   */
  async getFileStatus(): Promise<FileStatus> {
    const status: FileStatus = {
      envExists: fs_sync.existsSync(this.envPath),
      backupExists: fs_sync.existsSync(this.backupPath),
      templateExists: fs_sync.existsSync(this.templatePath),
    };

    if (status.envExists) {
      try {
        const stats = await fs.stat(this.envPath);
        status.envModified = stats.mtime;
        status.envSize = stats.size;
      } catch (error) {
        status.envError = (error as Error).message;
      }
    }

    if (status.backupExists) {
      try {
        const stats = await fs.stat(this.backupPath);
        status.backupModified = stats.mtime;
        status.backupSize = stats.size;
      } catch (error) {
        status.backupError = (error as Error).message;
      }
    }

    return status;
  }
}

export default EnvironmentManager;
