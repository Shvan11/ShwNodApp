/**
 * Environment Manager Service
 * Handles reading, writing, and managing .env configuration files
 */

import fs from 'fs/promises';
import fs_sync from 'fs';
import path from 'path';

class EnvironmentManager {
    constructor() {
        this.envPath = path.join(process.cwd(), '.env');
        this.backupPath = path.join(process.cwd(), '.env.backup');
        this.templatePath = path.join(process.cwd(), '.env.template');
    }

    /**
     * Read and parse the current .env file
     * @returns {Promise<Object>} Parsed environment variables
     */
    async readEnvFile() {
        try {
            const envContent = await fs.readFile(this.envPath, 'utf8');
            return this.parseEnvContent(envContent);
        } catch (error) {
            if (error.code === 'ENOENT') {
                console.warn('No .env file found, returning empty configuration');
                return {};
            }
            throw new Error(`Failed to read .env file: ${error.message}`);
        }
    }

    /**
     * Parse environment file content into key-value pairs
     * @param {string} content - Raw .env file content
     * @returns {Object} Parsed environment variables
     */
    parseEnvContent(content) {
        const env = {};
        const lines = content.split('\n');

        for (const line of lines) {
            const trimmed = line.trim();
            
            // Skip empty lines and comments
            if (!trimmed || trimmed.startsWith('#')) {
                continue;
            }

            // Parse key=value pairs
            const equalIndex = trimmed.indexOf('=');
            if (equalIndex > 0) {
                const key = trimmed.substring(0, equalIndex).trim();
                let value = trimmed.substring(equalIndex + 1).trim();

                // Remove quotes if present
                if ((value.startsWith('"') && value.endsWith('"')) ||
                    (value.startsWith("'") && value.endsWith("'"))) {
                    value = value.slice(1, -1);
                }

                env[key] = value;
            }
        }

        return env;
    }

    /**
     * Convert environment object back to .env file format
     * @param {Object} envVars - Environment variables object
     * @returns {string} Formatted .env file content
     */
    formatEnvContent(envVars) {
        const lines = [
            '# Database Configuration',
            '# Generated by Shwan Orthodontics Settings',
            `# Updated: ${new Date().toISOString()}`,
            ''
        ];

        // Database configuration section
        const dbVars = Object.keys(envVars)
            .filter(key => key.startsWith('DB_'))
            .sort();

        if (dbVars.length > 0) {
            lines.push('# Database Connection Settings');
            for (const key of dbVars) {
                const value = envVars[key];
                // Quote values that contain spaces or special characters
                const quotedValue = this.shouldQuoteValue(value) ? `"${value}"` : value;
                lines.push(`${key}=${quotedValue}`);
            }
            lines.push('');
        }

        // Other configuration sections
        const otherVars = Object.keys(envVars)
            .filter(key => !key.startsWith('DB_'))
            .sort();

        if (otherVars.length > 0) {
            lines.push('# Other Configuration');
            for (const key of otherVars) {
                const value = envVars[key];
                const quotedValue = this.shouldQuoteValue(value) ? `"${value}"` : value;
                lines.push(`${key}=${quotedValue}`);
            }
        }

        return lines.join('\n') + '\n';
    }

    /**
     * Determine if a value should be quoted in .env file
     * @param {string} value - Environment variable value
     * @returns {boolean} Whether the value should be quoted
     */
    shouldQuoteValue(value) {
        if (typeof value !== 'string') return false;
        
        // Quote if contains spaces, special characters, or is empty
        return value.includes(' ') || 
               value.includes('\t') || 
               value.includes('\n') ||
               value.includes('#') ||
               value.includes('=') ||
               value === '';
    }

    /**
     * Create a backup of the current .env file
     * @returns {Promise<boolean>} Success status
     */
    async createBackup() {
        try {
            if (fs_sync.existsSync(this.envPath)) {
                await fs.copyFile(this.envPath, this.backupPath);
                console.log('Environment backup created successfully');
                return true;
            }
            return false;
        } catch (error) {
            console.error('Failed to create environment backup:', error);
            throw new Error(`Backup creation failed: ${error.message}`);
        }
    }

    /**
     * Restore .env file from backup
     * @returns {Promise<boolean>} Success status
     */
    async restoreFromBackup() {
        try {
            if (fs_sync.existsSync(this.backupPath)) {
                await fs.copyFile(this.backupPath, this.envPath);
                console.log('Environment restored from backup successfully');
                return true;
            }
            throw new Error('No backup file found');
        } catch (error) {
            console.error('Failed to restore from backup:', error);
            throw new Error(`Restore failed: ${error.message}`);
        }
    }

    /**
     * Write new environment configuration to .env file
     * @param {Object} envVars - Environment variables to write
     * @param {boolean} createBackup - Whether to create backup first
     * @returns {Promise<boolean>} Success status
     */
    async writeEnvFile(envVars, createBackup = true) {
        try {
            // Create backup if requested and file exists
            if (createBackup) {
                await this.createBackup();
            }

            // Format and write new content
            const content = this.formatEnvContent(envVars);
            await fs.writeFile(this.envPath, content, 'utf8');
            
            console.log('Environment file updated successfully');
            return true;
        } catch (error) {
            console.error('Failed to write environment file:', error);
            throw new Error(`Write failed: ${error.message}`);
        }
    }

    /**
     * Update specific environment variables
     * @param {Object} updates - Variables to update
     * @param {boolean} createBackup - Whether to create backup first
     * @returns {Promise<Object>} Updated environment variables
     */
    async updateEnvVars(updates, createBackup = true) {
        try {
            // Read current environment
            const currentEnv = await this.readEnvFile();
            
            // Merge with updates
            const updatedEnv = { ...currentEnv, ...updates };
            
            // Write back to file
            await this.writeEnvFile(updatedEnv, createBackup);
            
            return updatedEnv;
        } catch (error) {
            console.error('Failed to update environment variables:', error);
            throw new Error(`Update failed: ${error.message}`);
        }
    }

    /**
     * Get database configuration from environment
     * @returns {Promise<Object>} Database configuration
     */
    async getDatabaseConfig() {
        try {
            const env = await this.readEnvFile();
            
            return {
                DB_SERVER: env.DB_SERVER || '',
                DB_INSTANCE: env.DB_INSTANCE || '',
                DB_DATABASE: env.DB_DATABASE || 'ShwanNew',
                DB_USER: env.DB_USER || '',
                DB_PASSWORD: env.DB_PASSWORD || '',
                DB_ENCRYPT: env.DB_ENCRYPT || 'false',
                DB_TRUST_CERTIFICATE: env.DB_TRUST_CERTIFICATE || 'true',
                DB_CONNECTION_TIMEOUT: env.DB_CONNECTION_TIMEOUT || '30000',
                DB_REQUEST_TIMEOUT: env.DB_REQUEST_TIMEOUT || '15000'
            };
        } catch (error) {
            console.error('Failed to get database configuration:', error);
            throw new Error(`Database config read failed: ${error.message}`);
        }
    }

    /**
     * Update database configuration
     * @param {Object} dbConfig - Database configuration object
     * @returns {Promise<Object>} Updated configuration
     */
    async updateDatabaseConfig(dbConfig) {
        try {
            // Validate required fields
            const required = ['DB_SERVER', 'DB_INSTANCE', 'DB_DATABASE', 'DB_USER', 'DB_PASSWORD'];
            for (const field of required) {
                if (!dbConfig[field] || dbConfig[field].trim() === '') {
                    throw new Error(`Required field ${field} is missing or empty`);
                }
            }

            // Prepare database-specific updates
            const dbUpdates = {};
            const validFields = [
                'DB_SERVER', 'DB_INSTANCE', 'DB_DATABASE', 'DB_USER', 'DB_PASSWORD',
                'DB_ENCRYPT', 'DB_TRUST_CERTIFICATE', 
                'DB_CONNECTION_TIMEOUT', 'DB_REQUEST_TIMEOUT'
            ];

            for (const field of validFields) {
                if (dbConfig[field] !== undefined) {
                    dbUpdates[field] = dbConfig[field].toString().trim();
                }
            }

            // Update environment
            const updatedEnv = await this.updateEnvVars(dbUpdates, true);
            
            // Return only database configuration
            return this.getDatabaseConfig();
        } catch (error) {
            console.error('Failed to update database configuration:', error);
            throw new Error(`Database config update failed: ${error.message}`);
        }
    }

    /**
     * Validate environment file exists and is readable
     * @returns {Promise<Object>} Validation result
     */
    async validateEnvironment() {
        try {
            const exists = fs_sync.existsSync(this.envPath);
            if (!exists) {
                return {
                    valid: false,
                    message: '.env file does not exist',
                    suggestions: ['Create .env file from template', 'Initialize with default values']
                };
            }

            const env = await this.readEnvFile();
            const dbConfig = await this.getDatabaseConfig();
            
            // Check for required database fields
            const required = ['DB_SERVER', 'DB_INSTANCE', 'DB_USER', 'DB_PASSWORD'];
            const missing = required.filter(field => !dbConfig[field]);

            if (missing.length > 0) {
                return {
                    valid: false,
                    message: `Missing required database configuration: ${missing.join(', ')}`,
                    missing: missing,
                    suggestions: ['Add missing database configuration fields']
                };
            }

            return {
                valid: true,
                message: 'Environment configuration is valid',
                config: dbConfig
            };
        } catch (error) {
            return {
                valid: false,
                message: `Environment validation failed: ${error.message}`,
                error: error.message
            };
        }
    }

    /**
     * Get configuration file status
     * @returns {Promise<Object>} File status information
     */
    async getFileStatus() {
        const status = {
            envExists: fs_sync.existsSync(this.envPath),
            backupExists: fs_sync.existsSync(this.backupPath),
            templateExists: fs_sync.existsSync(this.templatePath)
        };

        if (status.envExists) {
            try {
                const stats = await fs.stat(this.envPath);
                status.envModified = stats.mtime;
                status.envSize = stats.size;
            } catch (error) {
                status.envError = error.message;
            }
        }

        if (status.backupExists) {
            try {
                const stats = await fs.stat(this.backupPath);
                status.backupModified = stats.mtime;
                status.backupSize = stats.size;
            } catch (error) {
                status.backupError = error.message;
            }
        }

        return status;
    }
}

export default EnvironmentManager;